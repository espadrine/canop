<!doctype html><meta charset=utf-8>
<title> Convergent Collaborative Editing </title>
<link rel=stylesheet href=cm-3.16/lib/codemirror.css>
<body>
<script src=cm-3.16/lib/codemirror.js></script>
<script src=canop.js>/* Collaborative library */</script>
<script>

var Client = canop.Client;
var Operation = canop.Operation;

var editor = CodeMirror(document.body);
var shared = new Client();
var operation = new Operation();//

function editorChange(editor, change) {
  var from = change.from;
  var to = change.to;
  var text = change.text.join('\n');
  var removed = change.removed.join('\n');
  if (removed.length > 0) {
    shared.delete(editor.indexFromPos(from), removed);
  }
  if (text.length > 0) {
    shared.insert(editor.indexFromPos(from), text);
  }
  if (change.next) { editorChange(editor, change.next);
  } else {
    send();
  }
}

// Connection.

var socket = new WebSocket(
    // Trick: use the end of either http: or https:.
    'ws' + window.location.protocol.slice(4) + '//' +
      window.location.hostname +
      (window.location.port.length > 0? (':' + window.location.port): '') +
      '/$websocket:text');

function send() {
  if (shared.local.list.length > 0) {
    shared.prepareSent();
    console.log('> ' + JSON.stringify({ D: shared.sent.list }));
    socket.send(JSON.stringify({ D: shared.sent.list }));
  }
}

socket.onmessage = function recv(event) {
  var update = JSON.parse(event.data);
  console.log('< ' + JSON.stringify(update));
  if (update.M !== undefined) {
    editor.off('change', editorChange);
    editor.setValue(update.M);
    shared.reset(update.M, update.B);
    editor.on('change', editorChange);
  } else if (update.D !== undefined) {
    var change = Operation.fromList(update.D);
    var minimalDelta = merge(shared, change);
    //resetEditor(editor, shared);
    updateEditor(editor, minimalDelta);
  }
};

function resetEditor(editor, shared) {
  editor.off('change', editorChange);
  var cursor = editor.getCursor();
  editor.setValue(''+shared);
  editor.setCursor(cursor);
  editor.on('change', editorChange);
}

// Takes a Client and an operation.
// Returns a list of atomic operations.
function merge(shared, change) {
  var minimalDelta = editorUndoChanges();
  shared.receiveCanon(change);
  minimalDelta = minimalDelta.concat(editorChanges(change));
  return minimalDelta;
}

function editorUndoChanges() {
  var changes = [];
  for (var i = 0; i < shared.local.list.length; i++) {
    changes.push(inverseAtomicOperation(shared.local.list[i]));
  }
  for (var i = 0; i < shared.sent.list.length; i++) {
    changes.push(inverseAtomicOperation(shared.sent.list[i]));
  }
  return changes;
}

function editorChanges(op) {
  var changes = [];
  for (var i = 0; i < op.list.length; i++) {
    changes.push(op.list[i]);
  }
  for (var i = 0; i < shared.local.list.length; i++) {
    changes.push(shared.local.list[i]);
  }
  for (var i = 0; i < shared.sent.list.length; i++) {
    changes.push(shared.sent.list[i]);
  }
  return changes;
}

function inverseAtomicOperation(operation) {
  var inverse = operation.dup();
  // Insertions become deletions and vice-versa.
  inverse.tag = (inverse.tag === Client.TAG.insert)? Client.TAG.delete:
    Client.TAG.insert;
  return inverse;
};

// Takes a list of atomic operations.
function updateEditor(editor, delta) {
  editor.off('change', editorChange);
  var cursor = editor.getCursor();
  applyDelta(editor, delta);
  editor.setCursor(cursor);
  editor.on('change', editorChange);
}

function applyDelta(editor, delta) {
  for (var i = 0; i < delta.length; i++) {
    var change = delta[i];
    if (change.tag === Client.TAG.insert) {
      editor.replaceRange(change.string, editor.posFromIndex(change.offset));
    } else if (change.tag === Client.TAG.delete) {
      var from = editor.posFromIndex(change.offset);
      var to = editor.posFromIndex(change.offset + change.string.length);
      editor.replaceRange('', from, to);
    }
  }
}

</script>
</body>
